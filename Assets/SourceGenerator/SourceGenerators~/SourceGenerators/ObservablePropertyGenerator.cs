using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class ObservablePropertyGenerator : ISourceGenerator
{
    private const string Namespace = "MvvmTool";

    private const string AttributesSource =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Field)]
              public class ObservablePropertyAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Class)]
              public class INotifyPropertyChangedAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Method)]
              public class RelayCommandAttribute : System.Attribute { }
          }
          """;

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        GenerateAttributes(context);

        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        Compilation compilation = context.Compilation;

        // Process classes with the [INotifyPropertyChanged] attribute
        foreach (ClassDeclarationSyntax classWithAttribute in receiver.ClassesWithAttribute)
        {
            SemanticModel classSemanticModel = compilation.GetSemanticModel(classWithAttribute.SyntaxTree);
            var classWithAttributeSymbol = classSemanticModel.GetDeclaredSymbol(classWithAttribute) as INamedTypeSymbol;

            var fields = classWithAttribute.Members
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ObservableProperty")));

            List<IFieldSymbol> fieldsWithAttribute = [];
            foreach (FieldDeclarationSyntax field in fields)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(field.SyntaxTree);

                foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    fieldsWithAttribute.Add(fieldSymbol);
                }

                string source = GeneratePropertiesForClassWithAttribute(classWithAttributeSymbol, fieldsWithAttribute);
                context.AddSource($"{classWithAttributeSymbol?.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }

        // Process classes with the : INotifyPropertyChanged base interface
        foreach (ClassDeclarationSyntax classWithInterface in receiver.ClassesWithInterface)
        {
            SemanticModel classWithInterfaceSemanticModel =
                compilation.GetSemanticModel(classWithInterface.SyntaxTree);

            var classWithInterfaceSymbol =
                classWithInterfaceSemanticModel.GetDeclaredSymbol(classWithInterface) as INamedTypeSymbol;

            var fields2 = classWithInterface.Members
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ObservableProperty")));

            List<IFieldSymbol> fieldsWithInterfaceSymbols = [];
            foreach (FieldDeclarationSyntax field in fields2)
            {
                SemanticModel semanticModel = compilation.GetSemanticModel(field.SyntaxTree);

                foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    fieldsWithInterfaceSymbols.Add(fieldSymbol);
                }

                string source = GeneratePropertiesForClassWithInterface(classWithInterfaceSymbol, fieldsWithInterfaceSymbols);
                context.AddSource($"{classWithInterfaceSymbol?.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static void GenerateAttributes(GeneratorExecutionContext context)
    {
        context.AddSource("GeneratedAttributes.g.cs", SourceText.From(AttributesSource, Encoding.UTF8));
    }

    private static string GeneratePropertiesForClassWithAttribute(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");

        var ns = classSymbol.ContainingNamespace?.ToDisplayString();
        if (!string.IsNullOrWhiteSpace(ns) && !classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {ns} {{");
        }

        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"public partial class {classSymbol.Name} : INotifyPropertyChanged");
        sb.AppendLine("{");
        sb.AppendLine("    public event PropertyChangedEventHandler PropertyChanged;");

        foreach (IFieldSymbol field in fields)
        {
            var fieldName = field.Name;
            var fieldNameTrimmed = fieldName.TrimStart('_');
            var propertyName = char.ToUpper(fieldNameTrimmed[0]) + fieldNameTrimmed.Substring(1);
            var typeName = field.Type.ToDisplayString();

            sb.AppendLine($$"""

                                public {{typeName}} {{propertyName}}
                                {
                                    get => {{fieldName}};
                                    set
                                    {
                                        if (!EqualityComparer<{{typeName}}>.Default.Equals({{fieldName}}, value))
                                        {
                                            {{fieldName}} = value;
                                            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({{propertyName}})));
                                        }
                                    }
                                }
                            """);
        }

        sb.AppendLine("}");

        if (!string.IsNullOrWhiteSpace(ns) && !classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GeneratePropertiesForClassWithInterface(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/> \n");

        var classNameSpace = classSymbol.ContainingNamespace?.ToDisplayString();
        if (!string.IsNullOrWhiteSpace(classNameSpace) && !classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {classNameSpace} {{");
        }

        sb.AppendLine("using System;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine($"public partial class {classSymbol.Name}");
        sb.AppendLine("{");

        foreach (IFieldSymbol field in fields)
        {
            var fieldName = field.Name;
            var fieldNameTrimmed = fieldName.TrimStart('_');
            var propertyName = char.ToUpper(fieldNameTrimmed[0]) + fieldNameTrimmed.Substring(1);
            var typeName = field.Type.ToDisplayString();

            sb.AppendLine($$"""

                                public {{typeName}} {{propertyName}}
                                {
                                    get => {{fieldName}};
                                    set
                                    {
                                        if (!EqualityComparer<{{typeName}}>.Default.Equals({{fieldName}}, value))
                                        {
                                            {{fieldName}} = value;
                                            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({{propertyName}})));
                                        }
                                    }
                                }
                            """);
        }

        sb.AppendLine("}");

        if (!string.IsNullOrWhiteSpace(classNameSpace) && !classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    // Prefilter syntax nodes
    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesWithInterface { get; } = [];
        public List<ClassDeclarationSyntax> ClassesWithAttribute { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 } interfaceClass &&
                interfaceClass.BaseList.Types.Any(t => t.Type.ToString() == "INotifyPropertyChanged"))
            {
                ClassesWithInterface.Add(interfaceClass);
            }
            else if (node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } attributeClass &&
                     attributeClass.AttributeLists.Any(a =>
                     {
                         return a.Attributes.Any(attr => attr.Name.ToString() == "INotifyPropertyChanged");
                     }))
            {
                ClassesWithAttribute.Add(attributeClass);
            }
        }
    }
}