using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

// [Generator]
public class ObservablePropertyGenerator2 : ISourceGenerator
{
    private const string Namespace = "MvvmTool";

    private const string AttributesSource =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Field)]
              public class ObservablePropertyAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Class)]
              public class INotifyPropertyChangedAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Method)]
              public class RelayCommandAttribute : System.Attribute { }
          }
          """;

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        GenerateAttributes(context);

        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        Compilation compilation = context.Compilation;

        // Attributes
        var classFieldPairs = GetClassFieldsMethodsPairs(receiver.ClassesWithAttribute, compilation);
        foreach (KeyValuePair<INamedTypeSymbol, (List<IFieldSymbol>, List<IMethodSymbol>)> classFieldPair in classFieldPairs)
        {
            string source = GetSourceForAttributes(classFieldPair.Key, classFieldPair.Value.Item1, classFieldPair.Value.Item2);
            context.AddSource($"{classFieldPair.Key.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        // Interfaces
        classFieldPairs = GetClassFieldsMethodsPairs(receiver.ClassesWithInterface, compilation);
        foreach (KeyValuePair<INamedTypeSymbol, (List<IFieldSymbol>, List<IMethodSymbol>)> classFieldsPair in classFieldPairs)
        {
            string source = GetSourceForInterfaces(classFieldsPair.Key, classFieldsPair.Value.Item1, classFieldsPair.Value.Item2);
            context.AddSource($"{classFieldsPair.Key.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    private static Dictionary<INamedTypeSymbol, (List<IFieldSymbol>, List<IMethodSymbol>)> GetClassFieldsMethodsPairs(List<ClassDeclarationSyntax> classesWithAttribute, Compilation compilation)
    {
        Dictionary<INamedTypeSymbol, (List<IFieldSymbol>, List<IMethodSymbol>)> classFieldPairs = [];

        foreach (ClassDeclarationSyntax classWithAttribute in classesWithAttribute)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classWithAttribute.SyntaxTree);
            ISymbol declaredSymbol = semanticModel.GetDeclaredSymbol(classWithAttribute);

            if (declaredSymbol is not INamedTypeSymbol classWithAttributeSymbol)
            {
                continue;
            }

            var fields = classWithAttribute.Members
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ObservableProperty")));

            List<IFieldSymbol> fieldsWithAttribute = [];
            foreach (FieldDeclarationSyntax field in fields)
            {
                foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    fieldsWithAttribute.Add(fieldSymbol);
                }
            }

            var methods = classWithAttribute.Members
                .OfType<MethodDeclarationSyntax>()
                .Where(m => m.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString() == "RelayCommand"));

            List<IMethodSymbol> methodsWithAttribute = [];
            foreach (MethodDeclarationSyntax method in methods)
            {
                if (semanticModel.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol)
                {
                    continue;
                }

                methodsWithAttribute.Add(methodSymbol);
            }

            classFieldPairs.Add(classWithAttributeSymbol, (fieldsWithAttribute, methodsWithAttribute));
        }

        return classFieldPairs;
    }

    private static void GenerateAttributes(GeneratorExecutionContext context)
    {
        context.AddSource("GeneratedAttributes.g.cs", SourceText.From(AttributesSource, Encoding.UTF8));
    }

    private static string GetSourceForAttributes(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields,
        List<IMethodSymbol> methods)
    {
        return GetSource(classSymbol, fields, methods, true);
    }

    private static string GetSourceForInterfaces(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields,
        List<IMethodSymbol> methods)
    {
        return GetSource(classSymbol, fields, methods, false);
    }

    private static string GetSource(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields,
        List<IMethodSymbol> methods, bool isAttribute)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        var ns = classSymbol.ContainingNamespace?.ToDisplayString();
        bool hasNamespace = !string.IsNullOrWhiteSpace(ns) && !classSymbol.ContainingNamespace.IsGlobalNamespace;

        if (hasNamespace)
        {
            // Namespace start
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"public partial class {classSymbol.Name}");

        if (isAttribute)
        {
            sb.AppendLine("    : System.ComponentModel.INotifyPropertyChanged");
        }

        // Class start
        sb.AppendLine("{");

        if (isAttribute)
        {
            sb.AppendLine("    public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;");
        }

        foreach (IFieldSymbol field in fields)
        {
            var fieldName = field.Name;
            var fieldNameTrimmed = fieldName.TrimStart('_');
            var propertyName = char.ToUpper(fieldNameTrimmed[0]) + fieldNameTrimmed.Substring(1);
            var typeName = field.Type.ToDisplayString();

            sb.AppendLine($$"""
                                public {{typeName}} {{propertyName}}
                                {
                                    get => {{fieldName}};
                                    set
                                    {
                                        if (!System.Collections.Generic.EqualityComparer<{{typeName}}>.Default.Equals({{fieldName}}, value))
                                        {
                                            {{fieldName}} = value;
                                            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof({{propertyName}})));
                                        }
                                    }
                                }

                            """);
        }

        foreach (IMethodSymbol method in methods)
        {
            var methodName = method.Name;
            var propertyName = methodName + "Command";
            var fieldName = "_" + char.ToLower(propertyName[0]) + propertyName.Substring(1);

//              sb.AppendLine($"""
//                                  private DelegateCommand {fieldName};
//                                  public System.Windows.Input.ICommand {propertyName} => {fieldName} ??= new DelegateCommand({methodName});
//
//                              """);
        }

        // Class
        sb.AppendLine("}");

        if (hasNamespace)
        {
            // Namespace
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    // Prefilter syntax nodes
    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesWithInterface { get; } = [];
        public List<ClassDeclarationSyntax> ClassesWithAttribute { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 } interfaceClass &&
                interfaceClass.BaseList.Types.Any(t => t.Type.ToString() == "INotifyPropertyChanged"))
            {
                ClassesWithInterface.Add(interfaceClass);
            }
            else if (node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } attributeClass &&
                     attributeClass.AttributeLists.Any(a =>
                     {
                         return a.Attributes.Any(attr => attr.Name.ToString() == "INotifyPropertyChanged");
                     }))
            {
                ClassesWithAttribute.Add(attributeClass);
            }
        }
    }
}