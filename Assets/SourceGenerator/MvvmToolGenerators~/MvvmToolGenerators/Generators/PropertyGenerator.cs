using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MvvmToolGenerators.Tools;

namespace MvvmToolGenerators.Generators;

[Generator]
public class PropertyGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;

        if (compilation.IsUnityAndNotAssemblyCsharp())
        {
            return;
        }

        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        var classFieldPairs = GetClassFieldsPairs(receiver.ClassesForPropertyGeneration, compilation);

        foreach (KeyValuePair<INamedTypeSymbol, List<IFieldSymbol>> classFieldPair in classFieldPairs)
        {
            var (source, fileName) = GetSource(classFieldPair.Key, classFieldPair.Value);

            context.AddSource(fileName, source);
        }
    }

    private static Dictionary<INamedTypeSymbol, List<IFieldSymbol>> GetClassFieldsPairs(
        List<ClassDeclarationSyntax> classesWithAttribute, Compilation compilation)
    {
        Dictionary<INamedTypeSymbol, List<IFieldSymbol>> classFieldPairs = new(SymbolEqualityComparer.Default);
        // Class
        foreach (ClassDeclarationSyntax classWithAttribute in classesWithAttribute)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classWithAttribute.SyntaxTree);
            ISymbol? declaredSymbol = semanticModel.GetDeclaredSymbol(classWithAttribute);

            if (declaredSymbol is not INamedTypeSymbol classWithAttributeSymbol)
            {
                continue;
            }

            var fields = classWithAttribute.Members
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString() == "ObservableProperty"));

            // Field
            List<IFieldSymbol> fieldsWithAttribute = [];
            foreach (FieldDeclarationSyntax field in fields)
            {
                // Possible multiple variables in one field
                foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    fieldsWithAttribute.Add(fieldSymbol);
                }
            }

            if (fieldsWithAttribute.Count > 0)
            {
                classFieldPairs.Add(classWithAttributeSymbol, fieldsWithAttribute);
            }
        }

        return classFieldPairs;
    }

    private static (SourceText, string) GetSource(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        var namespaceName = classSymbol.ContainingNamespace?.ToDisplayString();
        bool hasNamespace = !string.IsNullOrWhiteSpace(namespaceName);
        string className = classSymbol.Name;

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        foreach (IFieldSymbol field in fields)
        {
            var fieldName = field.Name;
            var fieldNameTrimmed = fieldName.TrimStart('_');
            var propertyName = char.ToUpper(fieldNameTrimmed[0]) + fieldNameTrimmed.Substring(1);
            var typeName = field.Type.ToDisplayString();

            sb.AppendLine($$"""
                                public {{typeName}} {{propertyName}}
                                {
                                    get => {{fieldName}};
                                    set
                                    {
                                        if (!System.Collections.Generic.EqualityComparer<{{typeName}}>.Default.Equals({{fieldName}}, value))
                                        {
                                            {{fieldName}} = value;
                                            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof({{propertyName}})));
                                        }
                                    }
                                }

                            """);
        }

        sb.AppendLine("}"); // End of class

        if (hasNamespace)
        {
            sb.AppendLine("}"); // End of namespace
        }

        string source = sb.ToString();

        SourceText sourceText = SourceText.From(source, Encoding.UTF8);
        string fileName = $"{className}.Properties.g.cs";

        return (sourceText, fileName);
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesForPropertyGeneration { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 } interfaceClass &&
                interfaceClass.BaseList.Types.Any(t => t.Type.ToString() == "INotifyPropertyChanged"))
            {
                ClassesForPropertyGeneration.Add(interfaceClass);
            }
            else if (node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } attributeClass &&
                     attributeClass.AttributeLists.Any(a =>
                     {
                         return a.Attributes.Any(attr => attr.Name.ToString() == "INotifyPropertyChanged");
                     }))
            {
                ClassesForPropertyGeneration.Add(attributeClass);
            }
        }
    }
}