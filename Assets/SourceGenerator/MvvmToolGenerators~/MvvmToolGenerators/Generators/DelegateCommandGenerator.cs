using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MvvmToolGenerators.Generators;

[Generator]
public class CommandGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        foreach (ClassDeclarationSyntax classDeclarationSyntax in receiver.ClassesForCommandGeneration)
        {
            var (source, fileName) = GetSource(classDeclarationSyntax, context);

            if (source == null || fileName == null)
            {
                continue;
            }

            context.AddSource(fileName, source);
        }
    }

    private static (SourceText?, string?) GetSource(ClassDeclarationSyntax classDeclarationSyntax, GeneratorExecutionContext context)
    {
        SemanticModel semanticModel = context.Compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
        if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
        {
            return (null, null);
        }

        var methods = classDeclarationSyntax.Members
            .OfType<MethodDeclarationSyntax>()
            .Where(m => m.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(a => a.Name.ToString() == "RelayCommand")).ToArray();

        if (methods.Length == 0)
        {
            return (null, null);
        }

        string? nameSpaceName = classSymbol.ContainingNamespace?.ToDisplayString();
        bool hasNamespace = !string.IsNullOrWhiteSpace(nameSpaceName);
        string className = classSymbol.Name;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {nameSpaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        foreach (MethodDeclarationSyntax method in methods)
        {
            if (semanticModel.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol)
            {
                continue;
            }

            string methodName = methodSymbol.Name;
            string propertyName = methodSymbol.Name + "Command";
            string fieldName = "_" + char.ToLower(propertyName[0]) + propertyName.Substring(1);
            sb.AppendLine($"""
                                    private MvvmTool.DelegateCommand {fieldName};
                                    public System.Windows.Input.ICommand {propertyName} => {fieldName} ??= new MvvmTool.DelegateCommand({methodName});

                           """);
        }

        sb.AppendLine("}"); // End of class

        if (hasNamespace)
        {
            sb.AppendLine("}"); // End of namespace
        }

        string source = sb.ToString();

        SourceText sourceText = SourceText.From(source, Encoding.UTF8);
        string fileName = $"{className}.Commands.g.cs";

        return (sourceText, fileName);
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesForCommandGeneration { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax classDecl &&
                classDecl.Members
                    .OfType<MethodDeclarationSyntax>()
                    .Any(x => x.AttributeLists
                        .Any(al => al.Attributes
                            .Any(a => a.Name.ToString() == "DelegateCommand"))))
            {
                ClassesForCommandGeneration.Add(classDecl);
            }
        }
    }
}