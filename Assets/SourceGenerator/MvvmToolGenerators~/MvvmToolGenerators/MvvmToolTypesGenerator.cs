using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class TypesGenerator : ISourceGenerator
{
    private const string Namespace = "MvvmTool";

    private const string Types =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Field)]
              public class ObservablePropertyAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Class)]
              public class INotifyPropertyChangedAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Method)]
              public class RelayCommandAttribute : System.Attribute { }

              public class DelegateCommand: System.Windows.Input.ICommand
              {
                  public event System.EventHandler CanExecuteChanged;

                  private System.Func<object, bool> _canExecute;
                  private System.Action<object> _execute;

                  public DelegateCommand() { }

                  public DelegateCommand(System.Action<object> execute)
                  {
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public DelegateCommand(System.Func<object, bool> canExecute, System.Action<object> execute)
                  {
                      _canExecute = canExecute ?? throw new System.ArgumentNullException(nameof(canExecute));
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public bool CanExecute(object parameter)
                  {
                      return _canExecute == null || _canExecute(parameter);
                  }

                  public void Execute(object parameter)
                  {
                      _execute(parameter);
                  }

                  public void ReplaceCommand(System.Action<object> execute)
                  {
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public void ReplaceCanExecuteAndCommand(System.Func<object, bool> canExecute, System.Action<object> execute)
                  {
                      _canExecute = canExecute ?? throw new System.ArgumentNullException(nameof(canExecute));
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public void RaiseCanExecuteChanged()
                  {
                      System.EventHandler handler = CanExecuteChanged;
                      handler?.Invoke(this, System.EventArgs.Empty);
                  }
              }

          }
          """;

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;

        if (IsAssemblyCsharp(compilation))
        {
            return;
        }

        GenerateTypes(context);
    }

    private static bool IsAssemblyCsharp(Compilation compilation)
    {
        // Hack to avoid generating code for non Assembly-CSharp assemblies
        bool isUnity = IsUnity(compilation);
        bool isAssemblyCsharp = compilation.AssemblyName != "Assembly-CSharp";

        return isUnity && isAssemblyCsharp;
    }

    private static bool IsUnity(Compilation compilation)
    {
        bool isUnity = compilation.ReferencedAssemblyNames
            .Any(a => a.Name == "UnityEngine");

        return isUnity;
    }

    private static void GenerateTypes(GeneratorExecutionContext context)
    {
        context.AddSource("GeneratedMvvmToolTypes.g.cs", SourceText.From(Types, Encoding.UTF8));
    }
}