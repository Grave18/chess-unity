using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

[Generator]
public class PropertyAndCommandGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;

        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        // Attributes
        Dictionary<INamedTypeSymbol, List<IFieldSymbol>> classFieldPairs = GetClassFieldsPairs(receiver.ClassesWithAttribute, compilation);
        foreach (KeyValuePair<INamedTypeSymbol, List<IFieldSymbol>> classFieldPair in classFieldPairs)
        {
            string source = GetSourceForPropertiesAttributes(classFieldPair.Key, classFieldPair.Value);
            context.AddSource($"{classFieldPair.Key.Name}.Properties.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        // Interfaces
        classFieldPairs = GetClassFieldsPairs(receiver.ClassesWithInterface, compilation);
        foreach (KeyValuePair<INamedTypeSymbol, List<IFieldSymbol>> classFieldsPair in classFieldPairs)
        {
            string source = GetSourceForPropertiesWithInterfaces(classFieldsPair.Key, classFieldsPair.Value);
            context.AddSource($"{classFieldsPair.Key.Name}.Properties.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        AddSourceForCommands(context);
    }

    private static void AddSourceForCommands(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;
        if(context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        foreach(ClassDeclarationSyntax classDeclarationSyntax in receiver.ClassesWithAttribute.Union(receiver.ClassesWithInterface))
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var methods = classDeclarationSyntax.Members
                .OfType<MethodDeclarationSyntax>()
                .Where(m => m.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString() == "RelayCommand"));

            foreach (MethodDeclarationSyntax method in methods)
            {
                if (semanticModel.GetDeclaredSymbol(method) is not IMethodSymbol methodSymbol)
                {
                    continue;
                }

                string ns = classSymbol.ContainingNamespace?.ToDisplayString() ?? "DefaultNamespace";
                string className = classSymbol.Name;
                string methodName = methodSymbol.Name;
                string propertyName = methodSymbol.Name + "Command";
                string fieldName = "_" + char.ToLower(propertyName[0]) + propertyName.Substring(1);
                string source = $$"""
                                  // <auto-generated/>

                                  namespace {{ns}}
                                  {
                                      public partial class {{className}}
                                      {
                                           private MvvmTool.DelegateCommand {{fieldName}};
                                           public System.Windows.Input.ICommand {{propertyName}} => {{fieldName}} ??= new MvvmTool.DelegateCommand({{methodName}});
                                      }
                                  }
                                  """;

                context.AddSource($"{className}.Commands.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static Dictionary<INamedTypeSymbol, List<IFieldSymbol>> GetClassFieldsPairs(List<ClassDeclarationSyntax> classesWithAttribute, Compilation compilation)
    {
        Dictionary<INamedTypeSymbol, List<IFieldSymbol>> classFieldPairs = [];
        foreach (ClassDeclarationSyntax classWithAttribute in classesWithAttribute)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classWithAttribute.SyntaxTree);
            ISymbol declaredSymbol = semanticModel.GetDeclaredSymbol(classWithAttribute);

            if (declaredSymbol is not INamedTypeSymbol classWithAttributeSymbol)
            {
                continue;
            }

            var fields = classWithAttribute.Members
                .OfType<FieldDeclarationSyntax>()
                .Where(f => f.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Any(a => a.Name.ToString().Contains("ObservableProperty")));

            List<IFieldSymbol> fieldsWithAttribute = [];
            foreach (FieldDeclarationSyntax field in fields)
            {
                foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                {
                    if (semanticModel.GetDeclaredSymbol(variable) is not IFieldSymbol fieldSymbol)
                    {
                        continue;
                    }

                    fieldsWithAttribute.Add(fieldSymbol);
                    classFieldPairs.Add(classWithAttributeSymbol, fieldsWithAttribute);
                }
            }
        }

        return classFieldPairs;
    }

    private static string GetSourceForPropertiesAttributes(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
    {
        return GetSourceForProperties(classSymbol, fields, true);
    }

    private static string GetSourceForPropertiesWithInterfaces(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields)
    {
        return GetSourceForProperties(classSymbol, fields, false);
    }

    private static string GetSourceForProperties(INamedTypeSymbol classSymbol, List<IFieldSymbol> fields, bool isAttribute)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        var ns = classSymbol.ContainingNamespace?.ToDisplayString();
        bool hasNamespace = !string.IsNullOrWhiteSpace(ns) && !classSymbol.ContainingNamespace.IsGlobalNamespace;

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"public partial class {classSymbol.Name}");

        if (isAttribute)
        {
            sb.AppendLine("    : System.ComponentModel.INotifyPropertyChanged");
        }

        sb.AppendLine("{");

        if (isAttribute)
        {
            sb.AppendLine("    public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;");
        }

        foreach (IFieldSymbol field in fields)
        {
            var fieldName = field.Name;
            var fieldNameTrimmed = fieldName.TrimStart('_');
            var propertyName = char.ToUpper(fieldNameTrimmed[0]) + fieldNameTrimmed.Substring(1);
            var typeName = field.Type.ToDisplayString();

            sb.AppendLine($$"""
                                public {{typeName}} {{propertyName}}
                                {
                                    get => {{fieldName}};
                                    set
                                    {
                                        if (!System.Collections.Generic.EqualityComparer<{{typeName}}>.Default.Equals({{fieldName}}, value))
                                        {
                                            {{fieldName}} = value;
                                            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof({{propertyName}})));
                                        }
                                    }
                                }

                            """);
        }

        sb.AppendLine("}");

        if (hasNamespace)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    // Prefilter syntax nodes
    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesWithInterface { get; } = [];
        public List<ClassDeclarationSyntax> ClassesWithAttribute { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax { BaseList.Types.Count: > 0 } interfaceClass &&
                interfaceClass.BaseList.Types.Any(t => t.Type.ToString() == "INotifyPropertyChanged"))
            {
                ClassesWithInterface.Add(interfaceClass);
            }
            else if (node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } attributeClass &&
                     attributeClass.AttributeLists.Any(a =>
                     {
                         return a.Attributes.Any(attr => attr.Name.ToString() == "INotifyPropertyChanged");
                     }))
            {
                ClassesWithAttribute.Add(attributeClass);
            }
        }
    }
}