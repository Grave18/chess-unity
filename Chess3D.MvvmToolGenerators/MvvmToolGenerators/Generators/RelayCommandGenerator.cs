using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MvvmToolGenerators.Tools;

namespace MvvmToolGenerators.Generators;

[Generator]
public class RelayCommandGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        foreach (ClassDeclarationSyntax classDeclarationSyntax in receiver.ClassesForCommandGeneration)
        {
            var (source, fileName) = GetSource(classDeclarationSyntax, context);

            if (source == null || fileName == null)
            {
                continue;
            }

            context.AddSource(fileName, source);
        }
    }

    private (SourceText?, string?) GetSource(ClassDeclarationSyntax classDeclarationSyntax,
        GeneratorExecutionContext context)
    {
        SemanticModel semanticModel = context.Compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
        if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
        {
            return (null, null);
        }

        var methodsInfos = GetRelayCommandMethods(context, classDeclarationSyntax, semanticModel);

        if (methodsInfos.Count == 0)
        {
            return (null, null);
        }

        string? nameSpaceName = classSymbol.ContainingNamespace?.ToDisplayString();
        bool hasNamespace = !string.IsNullOrWhiteSpace(nameSpaceName);
        string className = classSymbol.Name;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine();

        if (hasNamespace)
        {
            sb.AppendLine($"namespace {nameSpaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        foreach (MethodInfo methodInfo in methodsInfos)
        {
            if (semanticModel.GetDeclaredSymbol(methodInfo.MethodDeclarationSyntax) is not IMethodSymbol methodSymbol)
            {
                continue;
            }

            string methodName = methodSymbol.Name;
            string commandPropertyName = methodName + "Command";
            string fieldName = "_" + char.ToLower(commandPropertyName[0]) + commandPropertyName.Substring(1);

            string parameters = methodInfo.HasCanExecuteMethod
                ? methodName + ", " + methodInfo.CanExecuteMethodName
                : methodName;

            string genericArgument = methodInfo.HasParameter
                ? "<" + methodInfo.MethodParameterTypeName + ">"
                : string.Empty;

            sb.AppendLine($"""
                                    private MvvmTool.RelayCommand{genericArgument} {fieldName};
                                    public MvvmTool.IRelayCommand{genericArgument} {commandPropertyName} => {fieldName} ??= new MvvmTool.RelayCommand{genericArgument}({parameters});

                           """);
        }

        sb.AppendLine("}"); // End of class

        if (hasNamespace)
        {
            sb.AppendLine("}"); // End of namespace
        }

        string source = sb.ToString();

        SourceText sourceText = SourceText.From(source, Encoding.UTF8);
        string fileName = $"{className}.Commands.g.cs";

        return (sourceText, fileName);
    }

    private static List<MethodInfo> GetRelayCommandMethods(GeneratorExecutionContext context,
        ClassDeclarationSyntax classDeclarationSyntax,
        SemanticModel semanticModel)
    {
        var methodDeclarationSyntaxes = classDeclarationSyntax.Members.OfType<MethodDeclarationSyntax>().ToArray();

        var methodInfos = new List<MethodInfo>();
        foreach (MethodDeclarationSyntax? method in methodDeclarationSyntaxes)
        {
            var attributes = method.AttributeLists.SelectMany(al => al.Attributes);
            foreach (AttributeSyntax attr in attributes)
            {
                if (attr.Name.ToString() == "RelayCommand")
                {
                    string? canExecuteMethodName = GetCanExecuteMethodName(attr, semanticModel);
                    CheckMethodsParametersEqual(context, method, canExecuteMethodName, methodDeclarationSyntaxes);

                    string? methodParameterTypeName = GetFirstParameterTypeName(method, semanticModel);

                    var methodInfo = new MethodInfo
                    {
                        MethodDeclarationSyntax = method,
                        CanExecuteMethodName = canExecuteMethodName,
                        MethodParameterTypeName = methodParameterTypeName
                    };

                    methodInfos.Add(methodInfo);
                }
            }
        }

        return methodInfos;
    }

    private static void CheckMethodsParametersEqual(GeneratorExecutionContext context, MethodDeclarationSyntax method,
        string? canExecuteMethodName, IEnumerable<MethodDeclarationSyntax> methods)
    {
        if (canExecuteMethodName == null)
        {
            return;
        }

        TypeSyntax? methodParam = method.ParameterList.Parameters.FirstOrDefault()?.Type;
        TypeSyntax? canExecuteParam = methods
            .FirstOrDefault(m => m.Identifier.ToString() == canExecuteMethodName)?
            .ParameterList.Parameters.FirstOrDefault()?.Type;

        bool isNotEqual = methodParam?.ToString() != canExecuteParam?.ToString();

        if (isNotEqual)
        {
            string methodName = method.Identifier.ToString();
            string methodParamName = methodParam == null ? "void" : methodParam.ToString();
            string message = $"Method and CanExecute method have different parameters:" +
                             $" {canExecuteMethodName} : {canExecuteParam}" +
                             $" and {methodName} : {methodParamName}";
            context.ShowDiagnostics("GEN", message, DiagnosticSeverity.Error);
        }
    }

    private static string? GetCanExecuteMethodName(AttributeSyntax attributeSyntax, SemanticModel semanticModel)
    {
        if (attributeSyntax.ArgumentList == null)
        {
            return null;
        }

        foreach (AttributeArgumentSyntax arg in attributeSyntax.ArgumentList.Arguments)
        {
            if (arg.NameEquals?.Name.Identifier.Text == "CanExecute")
            {
                var constValue = semanticModel.GetConstantValue(arg.Expression);
                if (constValue.HasValue)
                {
                    return constValue.Value?.ToString();
                }
            }
        }

        return null;
    }

    private static string? GetFirstParameterTypeName(MethodDeclarationSyntax method, SemanticModel semanticModel)
    {
        ParameterSyntax? firstParam = method.ParameterList.Parameters.FirstOrDefault();
        if (firstParam == null)
        {
            return null;
        }

        var paramSymbol = semanticModel.GetDeclaredSymbol(firstParam) as IParameterSymbol;
        string? parameterTypeName = paramSymbol?.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return parameterTypeName;
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> ClassesForCommandGeneration { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode node)
        {
            if (node is ClassDeclarationSyntax classDecl &&
                classDecl.Members
                    .OfType<MethodDeclarationSyntax>()
                    .Any(x => x.AttributeLists
                        .Any(al => al.Attributes
                            .Any(a =>
                                a.Name.ToString() == "RelayCommand"))))
            {
                ClassesForCommandGeneration.Add(classDecl);
            }
        }
    }

    private struct MethodInfo
    {
        public MethodDeclarationSyntax MethodDeclarationSyntax;
        public string? CanExecuteMethodName;
        public string? MethodParameterTypeName;
        public bool HasCanExecuteMethod => !string.IsNullOrWhiteSpace(CanExecuteMethodName);
        public bool HasParameter => !string.IsNullOrWhiteSpace(MethodParameterTypeName);
    }
}