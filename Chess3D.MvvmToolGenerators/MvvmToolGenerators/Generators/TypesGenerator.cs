using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using MvvmToolGenerators.Tools;

namespace MvvmToolGenerators.Generators;

[Generator]
public class TypesGenerator : ISourceGenerator
{
    public const string Namespace = "MvvmTool";

    public const string Types =
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              [System.AttributeUsage(System.AttributeTargets.Field)]
              public class ObservablePropertyAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Class)]
              public class INotifyPropertyChangedAttribute : System.Attribute { }

              [System.AttributeUsage(System.AttributeTargets.Method)]
              public class DelegateCommandAttribute : System.Attribute { }

              public class DelegateCommand: System.Windows.Input.ICommand
              {
                  public event System.EventHandler CanExecuteChanged;

                  private System.Func<object, bool> _canExecute;
                  private System.Action<object> _execute;

                  public DelegateCommand() { }

                  public DelegateCommand(System.Action<object> execute)
                  {
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public DelegateCommand(System.Func<object, bool> canExecute, System.Action<object> execute)
                  {
                      _canExecute = canExecute ?? throw new System.ArgumentNullException(nameof(canExecute));
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public bool CanExecute(object parameter)
                  {
                      return _canExecute == null || _canExecute(parameter);
                  }

                  public void Execute(object parameter)
                  {
                      _execute(parameter);
                  }

                  public void ReplaceCommand(System.Action<object> execute)
                  {
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public void ReplaceCanExecuteAndCommand(System.Func<object, bool> canExecute, System.Action<object> execute)
                  {
                      _canExecute = canExecute ?? throw new System.ArgumentNullException(nameof(canExecute));
                      _execute = execute ?? throw new System.ArgumentNullException(nameof(execute));
                  }

                  public void RaiseCanExecuteChanged()
                  {
                      System.EventHandler handler = CanExecuteChanged;
                      handler?.Invoke(this, System.EventArgs.Empty);
                  }
              }

              [System.AttributeUsage(System.AttributeTargets.Method)]
              public class RelayCommandAttribute : System.Attribute
              {
                  public string CanExecute;
              }

              public interface IRelayCommand : System.Windows.Input.ICommand
              {
                  void NotifyCanExecuteChanged();
              }

              public class RelayCommand : IRelayCommand
              {
                  private System.Action _execute;
                  private System.Func<bool> _canExecute;

                  public event System.EventHandler CanExecuteChanged;

                  public RelayCommand(System.Action execute = null, System.Func<bool> canExecute = null)
                  {
                      _execute = execute;
                      _canExecute = canExecute;
                  }

                  public bool CanExecute(object parameter)
                  {
                      return _canExecute?.Invoke() ?? true;
                  }

                  public void Execute(object parameter)
                  {
                      _execute?.Invoke();
                  }

                  public void NotifyCanExecuteChanged()
                  {
                      CanExecuteChanged?.Invoke(this, System.EventArgs.Empty);
                  }

                  public void Replace(System.Action execute, System.Func<bool> canExecute = null)
                  {
                      _canExecute = canExecute;
                      _execute = execute;
                  }
              }

              public interface IRelayCommand<T> : System.Windows.Input.ICommand
              {
                  void NotifyCanExecuteChanged();
              }

              public class RelayCommand<T> : IRelayCommand<T>
              {
                  private System.Action<T> _execute;
                  private System.Func<T, bool> _canExecute;

                  public event System.EventHandler CanExecuteChanged;

                  public RelayCommand(System.Action<T> execute = null, System.Func<T, bool> canExecute = null)
                  {
                      _execute = execute;
                      _canExecute = canExecute;
                  }

                  public bool CanExecute(object parameter)
                  {
                      if (_canExecute == null)
                      {
                          return true;
                      }

                      if (parameter == null && typeof(T).IsValueType)
                      {
                          return _canExecute(default);
                      }

                      return parameter is T typedParam && _canExecute(typedParam);
                  }

                  public void Execute(object parameter)
                  {
                      if (parameter == null && typeof(T).IsValueType)
                      {
                          _execute?.Invoke(default);
                      }
                      else if (parameter is T typedParam)
                      {
                          _execute?.Invoke(typedParam);
                      }
                  }

                  public void NotifyCanExecuteChanged()
                  {
                      CanExecuteChanged?.Invoke(this, System.EventArgs.Empty);
                  }

                  public void Replace(System.Action<T> execute, System.Func<T, bool> canExecute = null)
                  {
                      _execute = execute;
                      _canExecute = canExecute;
                  }
              }
          }
          """;

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        Compilation compilation = context.Compilation;

        if (compilation.IsUnityAndNotAssemblyCsharp())
        {
            return;
        }

        AddTypesSource(context);
    }

    private static void AddTypesSource(GeneratorExecutionContext context)
    {
        context.AddSource("GeneratedMvvmToolTypes.g.cs", SourceText.From(Types, Encoding.UTF8));
    }
}